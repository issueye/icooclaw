# 后端技术架构（Golang实现）

## 3.1 整体架构

```
+---------------------------------------------------------------------+
|                         Gateway Server                               |
|  +-------------+  +-------------+  +---------------------+           |
|  |   CLI       |  |   HTTP API  |  |   Channel Adapters |           |
|  |   Handler   |  |   Handler   |  |   (Multi-platform) |           |
|  +-------------+  +-------------+  +---------------------+           |
|           |              |                     |                      |
|           +--------------+---------------------+                      |
|                          v                                            |
|                 +----------------+                                    |
|                 |   Message Bus  |  (Channel-based Pub/Sub)          |
|                 +--------+-------+                                    |
|                          |                                            |
|     +--------------------+--------------------+                      |
|     v                    v                    v                      |
| +---------+       +-------------+      +-------------+               |
| |  Agent  |       |  Cron Job   |      |  Heartbeat  |               |
| |  Loop   |       |  Service    |      |  Service    |               |
| +----+----+       +-------------+      +-------------+               |
|      |                                                           |
|      v                                                           |
| +-----------------------------------------+                         |
| |           Tool Executor                  |                         |
| |  (File, Shell, Web, MCP, Cron, etc.)   |                         |
| +--------------------+--------------------+                         |
|                      v                                             |
| +-----------------------------------------+                         |
| |           LLM Provider                   |                         |
| |  (OpenAI, Anthropic, LiteLLM, etc.)    |                         |
| +-----------------------------------------+                         |
+---------------------------------------------------------------------+
```

## 3.2 核心模块设计

### 3.2.1 项目结构

```
icooclaw/
├── cmd/
│   ├── nanobot/
│   │   ├── main.go           # CLI入口
│   │   └── commands/         # CLI命令实现
│   └── gateway/              # Gateway服务入口
├── internal/
│   ├── agent/                # Agent核心逻辑
│   │   ├── loop.go           # Agent主循环
│   │   ├── context.go        # 上下文构建
│   │   ├── memory.go         # 记忆系统
│   │   ├── skills.go         # 技能加载
│   │   └── tools/            # 工具定义
│   ├── bus/                  # 消息总线
│   │   ├── bus.go            # 消息队列实现
│   │   └── events.go         # 事件定义
│   ├── channel/              # 通道适配器
│   │   ├── base.go           # 通道接口
│   │   ├── manager.go         # 通道管理器
│   │   ├── websocket.go      # WebSocket通道
│   │   ├── webhook.go        # Webhook通道
│   │   ├── telegram.go       # (后续支持)
│   │   ├── discord.go        # (后续支持)
│   │   ├── feishu.go         # (后续支持)
│   │   ├── dingtalk.go       # (后续支持)
│   │   ├── slack.go          # (后续支持)
│   │   ├── email.go          # (后续支持)
│   │   └── whatsapp.go       # (后续支持)
│   ├── provider/             # LLM Provider
│   │   ├── base.go           # Provider接口
│   │   ├── registry.go       # Provider注册表
│   │   ├── openai.go
│   │   ├── anthropic.go
│   │   ├── litellm.go        # LiteLLM封装
│   │   └── custom.go         # 自定义端点
│   ├── storage/              # 数据库存储
│   │   ├── db.go             # 数据库连接
│   │   ├── session.go        # 会话模型
│   │   ├── message.go        # 消息模型
│   │   └── task.go           # 任务模型
│   ├── scheduler/            # 定时任务
│   │   ├── cron.go
│   │   └── heartbeat.go
│   ├── config/               # 配置管理
│   │   └── config.go
│   └── mcp/                  # MCP客户端
│       ├── client.go
│       └── transport.go
├── pkg/
│   ├── tools/                # 内置工具
│   │   ├── file.go
│   │   ├── shell.go
│   │   ├── web.go
│   │   └── cron.go
│   └── utils/                # 工具函数
├── templates/                # 模板文件
│   ├── AGENTS.md
│   ├── SOUL.md
│   ├── USER.md
│   ├── TOOLS.md
│   └── MEMORY.md
├── skills/                   # 技能定义
├── workspace/                # 工作区（运行时生成）
├── config.toml               # 配置文件示例
└── go.mod
```

### 3.2.2 核心接口设计

#### Channel接口
```go
// Channel 消息通道接口
type Channel interface {
    Name() string
    Start(ctx context.Context) error
    Stop() error
    Send(ctx context.Context, msg OutboundMessage) error
    IsRunning() bool
}

// InboundHandler 接收消息处理
type InboundHandler interface {
    Handle(ctx context.Context, msg InboundMessage) error
}
```

#### Provider接口
```go
// Provider LLM Provider接口
type Provider interface {
    Chat(ctx context.Context, req ChatRequest) (*ChatResponse, error)
    GetDefaultModel() string
}

// ChatRequest 请求结构
type ChatRequest struct {
    Messages   []Message
    Tools      []ToolDefinition
    Model      string
    MaxTokens  int
    Temperature float
}

// ChatResponse 响应结构
type ChatResponse struct {
    Content         string
    ToolCalls       []ToolCall
    FinishReason    string
    Usage           Usage
    ReasoningContent string
}
```

#### Tool接口
```go
// Tool 工具接口
type Tool interface {
    Name() string
    Description() string
    Parameters() map[string]interface{}
    Execute(ctx context.Context, params map[string]interface{}) (string, error)
}
```

### 3.2.3 消息总线设计

```go
// MessageBus 异步消息队列
type MessageBus struct {
    inbound  chan InboundMessage
    outbound chan OutboundMessage
    // 每个channel独立的订阅
    subscribers map[string]chan InboundMessage
}

func (b *MessageBus) PublishInbound(ctx context.Context, msg InboundMessage) error
func (b *MessageBus) SubscribeInbound(channel string) <-chan InboundMessage
func (b *MessageBus) PublishOutbound(ctx context.Context, msg OutboundMessage) error
func (b *MessageBus) ConsumeInbound(ctx context.Context) (InboundMessage, error)
func (b *MessageBus) ConsumeOutbound(ctx context.Context) (OutboundMessage, error)
```

### 3.2.4 Agent Loop设计

```go
// Agent Agent核心结构
type Agent struct {
    provider  Provider
    tools     *ToolRegistry
    storage   *Storage
    memory    *MemoryStore
    skills    *SkillsLoader
    config    *AgentConfig
}

// RunAgentLoop Agent主循环
func (a *Agent) RunAgentLoop(ctx context.Context, initialMessages []Message) 
    (string, []string, []Message, error)

// 迭代逻辑：
// 1. 发送消息到LLM
// 2. 检查是否有tool_calls
//   - 有：执行工具，添加结果，继续循环
//   - 无：返回content，结束循环
```

### 3.2.5 数据库设计（SQLite + GORM）

使用 GORM 作为 ORM 框架，SQLite 作为嵌入式数据库。

#### 数据库表结构

```go
// Session 会话模型
type Session struct {
    ID                uint      `gorm:"primaryKey" json:"id"`
    Key               string    `gorm:"uniqueIndex;size:255" json:"key"`           // channel:chat_id
    Channel           string    `gorm:"size:50;index" json:"channel"`              // telegram, discord, feishu...
    ChatID            string    `gorm:"size:255;index" json:"chat_id"`            // 用户/群组ID
    UserID            string    `gorm:"size:255" json:"user_id"`                  // 用户唯一标识
    LastConsolidated  int       `gorm:"default:0" json:"last_consolidated"`        // 已整合的消息数
    Metadata          string    `gorm:"type:text" json:"metadata"`                 // JSON元数据
    CreatedAt         time.Time `json:"created_at"`
    UpdatedAt         time.Time `json:"updated_at"`
    
    Messages          []Message `gorm:"foreignKey:SessionID" json:"messages"`
}

// Message 消息模型
type Message struct {
    ID              uint      `gorm:"primaryKey" json:"id"`
    SessionID       uint      `gorm:"index" json:"session_id"`
    Role            string    `gorm:"size:20;index" json:"role"`                  // user, assistant, system, tool
    Content         string    `gorm:"type:text" json:"content"`
    ToolCalls       string    `gorm:"type:text" json:"tool_calls"`                // JSON数组
    ToolCallID      string    `gorm:"size:100" json:"tool_call_id"`               // 工具调用ID
    ToolName        string    `gorm:"size:100" json:"tool_name"`                 // 工具名称
    ReasoningContent string    `gorm:"type:text" json:"reasoning_content"`         // 思考过程
    Timestamp       time.Time `gorm:"index" json:"timestamp"`
    CreatedAt       time.Time `json:"created_at"`
}

// Task 定时任务模型
type Task struct {
    ID            uint      `gorm:"primaryKey" json:"id"`
    Name          string    `gorm:"size:100;uniqueIndex" json:"name"`
    Description   string    `gorm:"size:500" json:"description"`
    CronExpr      string    `gorm:"size:100" json:"cron_expr"`                    // Cron表达式
    Interval      int       `gorm:"default:0" json:"interval"`                    // 固定间隔(秒)
    Message       string    `gorm:"type:text" json:"message"`                     // 触发消息
    Channel       string    `gorm:"size:50" json:"channel"`                      // 投递通道
    ChatID        string    `gorm:"size:255" json:"chat_id"`                     // 投递目标
    Enabled       bool      `gorm:"default:true" json:"enabled"`
    NextRunAt     time.Time `gorm:"index" json:"next_run_at"`                     // 下次执行时间
    LastRunAt     time.Time `json:"last_run_at"`                                  // 上次执行时间
    CreatedAt     time.Time `json:"created_at"`
    UpdatedAt     time.Time `json:"updated_at"`
}

// Skill 技能模型
type Skill struct {
    ID          uint      `gorm:"primaryKey" json:"id"`
    Name        string    `gorm:"size:100;uniqueIndex" json:"name"`
    Source      string    `gorm:"size:20" json:"source"`                         // builtin, workspace, remote
    Description string    `gorm:"size:500" json:"description"`
    Content     string    `gorm:"type:text" json:"content"`                      // SKILL.md内容
    Enabled     bool      `gorm:"default:true" json:"enabled"`
    AlwaysLoad  bool      `gorm:"default:false" json:"always_load"`               // 是否总是加载
    Metadata    string    `gorm:"type:text" json:"metadata"`                     // JSON元数据
    CreatedAt   time.Time `json:"created_at"`
    UpdatedAt   time.Time `json:"updated_at"`
}

// Memory 长期记忆模型
type Memory struct {
    ID        uint      `gorm:"primaryKey" json:"id"`
    Type      string    `gorm:"size:20;index" json:"type"`                       // memory, history
    Key       string    `gorm:"size:255;index" json:"key"`                       // 记忆键
    Content   string    `gorm:"type:text" json:"content"`                        // 记忆内容
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}

// ChannelConfig 通道配置模型
type ChannelConfig struct {
    ID        uint      `gorm:"primaryKey" json:"id"`
    Name      string    `gorm:"size:50;uniqueIndex" json:"name"`                 // telegram, discord...
    Enabled   bool      `gorm:"default:false" json:"enabled"`
    Config    string    `gorm:"type:text" json:"config"`                         // JSON配置
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}

// ProviderConfig Provider配置模型
type ProviderConfig struct {
    ID        uint      `gorm:"primaryKey" json:"id"`
    Name      string    `gorm:"size:50;uniqueIndex" json:"name"`                 // openai, anthropic...
    Enabled   bool      `gorm:"default:false" json:"enabled"`
    Config    string    `gorm:"type:text" json:"config"`                         // JSON配置
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}
```

#### 数据库初始化

```go
// DB 数据库连接实例
var DB *gorm.DB

// InitDB 初始化数据库
func InitDB(dsn string) error {
    var err error
    
    // 使用 glebarez/go-sqlite 驱动
    DB, err = gorm.Open(sqlite.Open(dsn), &gorm.Config{
        Logger: logger.Default.LogMode(logger.Info),
    })
    if err != nil {
        return fmt.Errorf("failed to connect database: %w", err)
    }
    
    // 自动迁移
    err = DB.AutoMigrate(
        &Session{},
        &Message{},
        &Task{},
        &Skill{},
        &Memory{},
        &ChannelConfig{},
        &ProviderConfig{},
    )
    if err != nil {
        return fmt.Errorf("failed to migrate database: %w", err)
    }
    
    return nil
}
```

### 3.2.6 配置设计（TOML格式）

```go
// Config 全局配置
type Config struct {
    Providers  ProvidersConfig  `toml:"providers"`
    Channels   ChannelsConfig   `toml:"channels"`
    Agents     AgentsConfig     `toml:"agents"`
    Tools      ToolsConfig      `toml:"tools"`
    Workspace  string           `toml:"workspace"`
    Database   DatabaseConfig   `toml:"database"`
    Log        LogConfig        `toml:"log"`
}

// ProvidersConfig Provider配置
type ProvidersConfig struct {
    OpenRouter *ProviderConfig `toml:"openrouter"`
    OpenAI     *ProviderConfig `toml:"openai"`
    Anthropic  *ProviderConfig `toml:"anthropic"`
    DeepSeek   *ProviderConfig `toml:"deepseek"`
    Custom     *ProviderConfig `toml:"custom"`
}

// ProviderConfig 单个Provider配置
type ProviderConfig struct {
    Enabled  bool   `toml:"enabled"`
    APIKey   string `toml:"api_key"`
    APIBase  string `toml:"api_base"`
    Model    string `toml:"model"`
}

// DatabaseConfig 数据库配置
type DatabaseConfig struct {
    Path string `toml:"path"`  // SQLite数据库文件路径
}

// LogConfig 日志配置
type LogConfig struct {
    Level  string `toml:"level"`   // debug, info, warn, error
    Format string `toml:"format"`  // json, text
}
```

#### TOML配置文件示例

```toml
# icooclaw 配置文件示例
# config.toml

# ============================================
# 数据库配置
# ============================================
[database]
path = "./data/nanobot.db"

# ============================================
# 日志配置
# ============================================
[log]
level = "info"      # debug, info, warn, error
format = "text"     # json, text

# ============================================
# 工作区配置
# ============================================
workspace = "~/.nanobot/workspace"

# ============================================
# LLM Provider配置
# ============================================
[providers.openrouter]
enabled = true
api_key = "sk-or-v1-xxxx"
model = "anthropic/claude-opus-4-5"

[providers.anthropic]
enabled = false
api_key = "sk-ant-xxxx"

[providers.openai]
enabled = false
api_key = "sk-xxxx"

[providers.deepseek]
enabled = false
api_key = "sk-xxxx"

[providers.custom]
enabled = false
api_key = "no-key"
api_base = "http://localhost:8000/v1"
model = "qwen2.5"

# ============================================
# Agent配置
# ============================================
[agents.defaults]
model = "anthropic/claude-opus-4-5"
temperature = 0.7
max_tokens = 4096
memory_window = 50

# ============================================
# 消息通道配置
# ============================================
[channels.telegram]
enabled = false
token = "1234567890:ABCdefGHIjklMNOpqrsTUVwxyz"

[channels.discord]
enabled = false
token = "xxxx"

[channels.feishu]
enabled = false
app_id = "cli_xxxx"
app_secret = "xxxx"

[channels.dingtalk]
enabled = false
client_id = "xxxx"
client_secret = "xxxx"

[channels.slack]
enabled = false
bot_token = "xoxb-xxxx"
app_token = "xapp-xxxx"

[channels.email]
enabled = false
imap_host = "imap.gmail.com"
imap_port = 993
smtp_host = "smtp.gmail.com"
smtp_port = 587

# ============================================
# MCP配置
# ============================================
[tools.mcp_servers]
[tools.mcp_servers.filesystem]
command = "npx"
args = ["-y", "@modelcontextprotocol/server-filesystem", "/path/to/dir"]

# ============================================
# 安全配置
# ============================================
[security]
restrict_to_workspace = false
```

## 3.3 关键技术决策

### 3.3.1 框架选型

- **Web框架：** Golang 原生 `net/http`（轻量、无外部依赖、高性能）
- **数据库：** SQLite + GORM（`github.com/glebarez/go-sqlite`）
- **日志：** Golang 原生 `log/slog`（结构化日志，Go 1.21+内置）
- **配置：** Viper + TOML 格式（支持TOML/JSON/YAML/ENV）
- **异步处理：** 原生 `context` + `goroutine` + `sync`

**选型理由：**

| 组件 | 选型 | 理由 |
|------|------|------|
| Web框架 | 原生net/http | 轻量级、无外部依赖、足够高性能 |
| 数据库 | SQLite + GORM | 嵌入式、零运维、适合个人项目 |
| 日志 | slog | Go原生、标准库一部分、性能优秀 |
| 配置 | Viper + TOML | TOML语法简洁、适合配置文件 |

### 3.3.2 HTTP服务实现（原生net/http）

使用原生 `net/http` 实现轻量级HTTP服务：

```go
// HTTPServer HTTP服务器
type HTTPServer struct {
    addr   string
    router *Router
    logger *slog.Logger
}

// NewHTTPServer 创建HTTP服务器
func NewHTTPServer(addr string, logger *slog.Logger) *HTTPServer {
    return &HTTPServer{
        addr:   addr,
        router: NewRouter(),
        logger: logger,
    }
}

// Router 简单路由器
type Router struct {
    handlers map[string]http.HandlerFunc
    logger   *slog.Logger
}

func (r *Router) Handle(path string, handler http.HandlerFunc) {
    r.handlers[path] = handler
}

func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    // 简单的路由匹配逻辑
    handler, ok := r.handlers[req.URL.Path]
    if !ok {
        http.NotFound(w, req)
        return
    }
    handler(w, req)
}
```

### 3.3.3 日志系统实现（slog）

使用原生 `log/slog` 实现结构化日志：

```go
// InitLogger 初始化日志系统
func InitLogger(level string, format string) *slog.Logger {
    var handler slog.Handler
    
    opts := &slog.HandlerOptions{
        AddSource: true,
    }
    
    // 根据级别设置
    switch level {
    case "debug":
        opts.Level = slog.LevelDebug
    case "info":
        opts.Level = slog.LevelInfo
    case "warn":
        opts.Level = slog.LevelWarn
    case "error":
        opts.Level = slog.LevelError
    default:
        opts.Level = slog.LevelInfo
    }
    
    // 根据格式选择处理器
    if format == "json" {
        handler = slog.NewJSONHandler(os.Stdout, opts)
    } else {
        handler = slog.NewTextHandler(os.Stdout, opts)
    }
    
    return slog.New(handler)
}

// 使用示例
logger.Info("Agent started", 
    slog.String("model", "claude-opus"),
    slog.Int("channels", len(channels)),
)
```

### 3.3.4 Provider实现策略

使用**注册表模式**，类似Python版本的ProviderRegistry：

```go
// ProviderSpec Provider规格定义
type ProviderSpec struct {
    Name            string
    Keywords        []string
    EnvKey          string
    DisplayName     string
    LiteLLMPrefix   string
    SkipPrefixes    []string
    // ...
}

var providerRegistry = make(map[string]*ProviderSpec)

// RegisterProvider 注册Provider
func RegisterProvider(spec *ProviderSpec) {
    providerRegistry[spec.Name] = spec
}
```

### 3.3.5 Channel实现策略

每个Channel作为独立的goroutine运行：

```go
func (c *TelegramChannel) Start(ctx context.Context) error {
    go c.poll(ctx)  // 长轮询
    <-ctx.Done()
    return c.Stop()
}
```

### 3.3.6 MCP集成

使用 `github.com/mark3labs/mcp-go` 实现 MCP 客户端：

```go
// MCPClient MCP客户端
import "github.com/mark3labs/mcp-go"

type MCPClient struct {
    client    *mcpgo.Client
    transport mcpgo.Transport  // stdio or http/sse
    tools     []Tool
}

// NewMCPClient 创建MCP客户端
func NewMCPClient(config MCPConfig) (*MCPClient, error) {
    client := mcpgo.NewClient(config.ServerURL, config.Transport)
    return &MCPClient{
        client:    client,
        transport: config.Transport,
    }, nil
}
```
